import groovy.json.JsonOutput

// ==================== è¾…åŠ©å‡½æ•°å®šä¹‰åŒºåŸŸ ====================

@NonCPS
def getRepositoryUrl(repoName) {
	def repoMap = [
		'zcf-charge-operation-platform': 'https://codeup.aliyun.com/6552e8ef77eababf21d319a4/business-platform/backend/zcf-charge-operation-platform.git',
		'zcf-busi-middle-office': 'https://codeup.aliyun.com/6552e8ef77eababf21d319a4/middle-office/backend/zcf-busi-middle-office.git',
		'zcf-iot-gateway': 'https://codeup.aliyun.com/6552e8ef77eababf21d319a4/base-framework/backend/zcf-iot-gateway.git',
		'zcf-charge-plat': 'https://codeup.aliyun.com/6552e8ef77eababf21d319a4/business-platform/frontend/zcf-charge-operation-platform-web.git',
		'zcf-charge-tenant': 'https://codeup.aliyun.com/6552e8ef77eababf21d319a4/business-platform/frontend/zcf-charge-operation-tenant-web.git',
		'zcf-data-platform-jobs': 'https://codeup.aliyun.com/6552e8ef77eababf21d319a4/data-middle-office/backend/zcf-data-middle-office-job.git',
		'zcf-data-platform-engine': 'https://codeup.aliyun.com/6552e8ef77eababf21d319a4/data-middle-office/backend/zcf-data-middle-office-job-framework.git',
		'zcf-charge-h5': 'https://codeup.aliyun.com/6552e8ef77eababf21d319a4/business-platform/frontend/zcf-charge-operation-h5.git'
	]
	return repoMap[repoName]
}

@NonCPS
def isFrontendProject(repoName) {
	def frontendProjects = ['zcf-charge-plat', 'zcf-charge-tenant','zcf-charge-h5']
	return frontendProjects.contains(repoName) ? 'true' : 'false'
}

@NonCPS
def parseModuleVersions(String moduleVersionsText) {
	def versionMap = [:]
	if (moduleVersionsText && moduleVersionsText.trim()) {
		moduleVersionsText.split('\n').each { line ->
			line = line.trim()
			if (line && !line.startsWith('#') && !line.startsWith('//')) {
				def parts = line.split('=')
				if (parts.size() == 2) {
					versionMap[parts[0].trim()] = parts[1].trim()
				}
			}
		}
	}
	return versionMap
}

/**
 * ç”Ÿæˆæ¨¡å—ç‰ˆæœ¬å·ï¼ˆç»Ÿä¸€æ ¼å¼ï¼šcommitTime-refName-versionï¼‰
 * @param moduleName æ¨¡å—åç§°
 * @param versionMap ç‰ˆæœ¬æ˜ å°„è¡¨ï¼ˆæ¥è‡ª AUTO_INCREMENT æˆ– MANUAL æ¨¡å¼ï¼‰
 * @param gitCommitTime Git æäº¤æ—¶é—´
 * @param refName åˆ†æ”¯æˆ–æ ‡ç­¾åç§°
 * @param defaultVersion é»˜è®¤ç‰ˆæœ¬å·ï¼ˆDEFAULT æ¨¡å¼ä½¿ç”¨ï¼‰
 */
@NonCPS
def getModuleVersion(String moduleName, Map versionMap, String gitCommitTime, String refName, String defaultVersion) {
	def baseVersion = ''

	if (versionMap.containsKey(moduleName)) {
		// AUTO_INCREMENT æˆ– MANUAL æ¨¡å¼ï¼šä½¿ç”¨æ˜ å°„è¡¨ä¸­çš„ç‰ˆæœ¬
		baseVersion = versionMap[moduleName]
	} else {
		// DEFAULT æ¨¡å¼ï¼šä½¿ç”¨é»˜è®¤ç‰ˆæœ¬
		baseVersion = defaultVersion
	}

	// ç»Ÿä¸€æ ¼å¼ï¼šcommitTime-refName-version
	return "${gitCommitTime}-${refName}-${baseVersion}"
}

@NonCPS
def parseSemanticVersion(String version) {
	if (!version) return null
	def cleanVersion = version.replaceAll(/^[vV]/, '').replaceAll(/-.*$/, '')
	def pattern = /^(\d+)\.(\d+)\.(\d+)$/
	def matcher = cleanVersion =~ pattern
	if (matcher.matches()) {
		return [major: matcher.group(1).toInteger(), minor: matcher.group(2).toInteger(), patch: matcher.group(3).toInteger(), original: version]
	}
	pattern = /^(\d+)\.(\d+)$/
	matcher = cleanVersion =~ pattern
	if (matcher.matches()) {
		return [major: matcher.group(1).toInteger(), minor: matcher.group(2).toInteger(), patch: 0, original: version]
	}
	return null
}

@NonCPS
def compareVersions(def v1, def v2) {
	if (!v1) return v2
	if (!v2) return v1
	if (v1.major != v2.major) return v1.major > v2.major ? v1 : v2
	if (v1.minor != v2.minor) return v1.minor > v2.minor ? v1 : v2
	if (v1.patch != v2.patch) return v1.patch > v2.patch ? v1 : v2
	return v1
}

@NonCPS
def findLatestVersion(List versions) {
	if (!versions || versions.isEmpty()) return null
	def latestParsed = null
	versions.each { version ->
		def parsed = parseSemanticVersion(version)
		if (parsed) {
			latestParsed = compareVersions(latestParsed, parsed)
		}
	}
	return latestParsed
}

@NonCPS
def incrementVersion(def parsedVersion, String incrementType) {
	if (!parsedVersion) return null
	switch (incrementType) {
	case 'MAJOR': return "${parsedVersion.major + 1}.0.0"
	case 'MINOR': return "${parsedVersion.major}.${parsedVersion.minor + 1}.0"
	case 'PATCH':
	default: return "${parsedVersion.major}.${parsedVersion.minor}.${parsedVersion.patch + 1}"
	}
}

@NonCPS
def decodeUnicode(String text) {
	def result = new StringBuilder()
	def i = 0
	while (i < text.length()) {
		if (text[i] == '\\' && i + 5 < text.length() && text[i + 1] == 'u') {
			try {
				def unicode = text.substring(i + 2, i + 6)
				def ch = (char) Integer.parseInt(unicode, 16)
				result.append(ch)
				i += 6
			} catch (Exception e) {
				result.append(text[i])
				i++
			}
		} else {
			result.append(text[i])
			i++
		}
	}
	return result.toString()
}

// ==================== Pipeline å‚æ•°é…ç½® ====================

properties([
	parameters([
		choice(
			name: 'BUILD_TYPE',
			choices: ['BRANCH', 'TAG'],
			description: 'é€‰æ‹©æ„å»ºç±»å‹ï¼šåˆ†æ”¯æ„å»ºæˆ–æ ‡ç­¾æ„å»º'
		),

		choice(
			name: 'REPOSITORY',
			choices: [
				'zcf-charge-operation-platform',
				'zcf-busi-middle-office',
				'zcf-iot-gateway',
				'zcf-data-platform-jobs',
				'zcf-charge-plat',
				'zcf-charge-tenant',
				'zcf-data-platform-engine',
				'zcf-charge-h5'
			],
			description: 'é€‰æ‹©è¦æ„å»ºçš„ä»£ç ä»“åº“'
		),

		[$class: 'CascadeChoiceParameter',
			choiceType: 'PT_SINGLE_SELECT',
			name: 'BRANCH_OR_TAG',
			referencedParameters: 'REPOSITORY,BUILD_TYPE',
			script: [
				$class: 'GroovyScript',
				fallbackScript: [
					sandbox: true,
					script: 'return ["è¯·å…ˆé€‰æ‹©ä»£ç ä»“åº“å’Œæ„å»ºç±»å‹"]'
				],
				script: [
					sandbox: false,
					script: '''
                       import jenkins.model.Jenkins
                        import com.cloudbees.plugins.credentials.CredentialsProvider
                        import com.cloudbees.plugins.credentials.common.StandardUsernamePasswordCredentials
                        import com.cloudbees.plugins.credentials.domains.DomainRequirement

                        def getCredentials(String credentialsId) {
                            def creds = CredentialsProvider.lookupCredentials(
                                StandardUsernamePasswordCredentials.class,
                                Jenkins.instance,
                                null,
                                Collections.<DomainRequirement>emptyList()
                            )
                            return creds.find { it.id == credentialsId }
                        }

                        def credentialsId = '99b27b05-ecce-4a92-a478-f806be8528f3'
                        def credentials = getCredentials(credentialsId)

                        if (!credentials) {
                            return ['é”™è¯¯: æœªæ‰¾åˆ°å‡­æ®']
                        }

                        def username = credentials.username
                        def password = credentials.password.plainText

                        def repoMap = [
                        		'zcf-charge-operation-platform': 'https://codeup.aliyun.com/6552e8ef77eababf21d319a4/business-platform/backend/zcf-charge-operation-platform.git',
								'zcf-busi-middle-office': 'https://codeup.aliyun.com/6552e8ef77eababf21d319a4/middle-office/backend/zcf-busi-middle-office.git',
								'zcf-iot-gateway': 'https://codeup.aliyun.com/6552e8ef77eababf21d319a4/base-framework/backend/zcf-iot-gateway.git',
								'zcf-charge-plat': 'https://codeup.aliyun.com/6552e8ef77eababf21d319a4/business-platform/frontend/zcf-charge-operation-platform-web.git',
								'zcf-charge-tenant': 'https://codeup.aliyun.com/6552e8ef77eababf21d319a4/business-platform/frontend/zcf-charge-operation-tenant-web.git',
								'zcf-data-platform-jobs': 'https://codeup.aliyun.com/6552e8ef77eababf21d319a4/data-middle-office/backend/zcf-data-middle-office-job.git',
								'zcf-data-platform-engine': 'https://codeup.aliyun.com/6552e8ef77eababf21d319a4/data-middle-office/backend/zcf-data-middle-office-job-framework.git',
                        		'zcf-charge-h5': 'https://codeup.aliyun.com/6552e8ef77eababf21d319a4/business-platform/frontend/zcf-charge-operation-h5.git'
                        ]

                        def repoUrl = repoMap[REPOSITORY]

                        if (!repoUrl) {
                            return ['è¯·å…ˆé€‰æ‹©ä»£ç ä»“åº“']
                        }

                        def authenticatedUrl = repoUrl.replace('https://', "https://${username}:${password}@")

                        try {
                            def command
                            if (BUILD_TYPE == 'TAG') {
                                command = "git ls-remote --tags ${authenticatedUrl}"
                            } else {
                                command = "git ls-remote -h ${authenticatedUrl}"
                            }

                            def proc = command.execute()
                            proc.waitForOrKill(30000)

                            def exitCode = proc.exitValue()
                            def output = proc.text

                            if (exitCode != 0) {
                                return ['è·å–å¤±è´¥ï¼Œè¯·æ£€æŸ¥å‡­æ®å’Œç½‘ç»œ']
                            }

                            def results = []

                            if (BUILD_TYPE == 'TAG') {
                                output.eachLine { line ->
                                    if (line && line.trim()) {
                                        def parts = line.trim().split(/\\s+/)
                                        if (parts.size() >= 2 && parts[1].startsWith('refs/tags/')) {
                                            def tagName = parts[1].replace('refs/tags/', '')
                                            if (!tagName.endsWith('^{}')) {
                                                results.add(tagName.toString())
                                            }
                                        }
                                    }
                                }
                            } else {
                                output.eachLine { line ->
                                    if (line && line.trim()) {
                                        def parts = line.trim().split(/\\s+/)
                                        if (parts.size() >= 2 && parts[1].startsWith('refs/heads/')) {
                                            def branchName = parts[1].replace('refs/heads/', '')
                                            results.add("origin/${branchName}".toString())
                                        }
                                    }
                                }
                            }

                            if (results.isEmpty()) {
                                return BUILD_TYPE == 'TAG' ? ['æœªæ‰¾åˆ°æ ‡ç­¾'] : ['æœªæ‰¾åˆ°åˆ†æ”¯']
                            }

                            return results.sort().reverse().collect { it.toString() }

                        } catch (Exception e) {
                            return ["å¼‚å¸¸: ${e.message}".toString()]
                        }
                    '''
				]
			],
			description: 'é€‰æ‹©è¦æ„å»ºçš„åˆ†æ”¯æˆ–æ ‡ç­¾'
		],

		[$class: 'CascadeChoiceParameter',
			choiceType: 'PT_CHECKBOX',
			name: 'BUILD_MODULES',
			referencedParameters: 'REPOSITORY,BRANCH_OR_TAG',
			script: [
				$class: 'GroovyScript',
				fallbackScript: [
					sandbox: true,
					script: 'return ["è¯·å…ˆé€‰æ‹©ä»£ç ä»“åº“å’Œåˆ†æ”¯/æ ‡ç­¾"]'
				],
				script: [
					sandbox: false,
					script: '''
                        import jenkins.model.Jenkins
                        import com.cloudbees.plugins.credentials.CredentialsProvider
                        import com.cloudbees.plugins.credentials.common.StandardUsernamePasswordCredentials
                        import com.cloudbees.plugins.credentials.domains.DomainRequirement

                        def frontendProjects = ['zcf-charge-h5', 'zcf-charge-plat', 'zcf-charge-tenant']

                        if (frontendProjects.contains(REPOSITORY)) {
                            return ['å‰ç«¯é¡¹ç›®æ— éœ€é€‰æ‹©æ¨¡å—']
                        }

                        def getCredentials(String credentialsId) {
                            def creds = CredentialsProvider.lookupCredentials(
                                StandardUsernamePasswordCredentials.class,
                                Jenkins.instance,
                                null,
                                Collections.<DomainRequirement>emptyList()
                            )
                            return creds.find { it.id == credentialsId }
                        }

                        def credentialsId = '99b27b05-ecce-4a92-a478-f806be8528f3'
                        def credentials = getCredentials(credentialsId)

                        if (!credentials) {
                            return ['é”™è¯¯: æœªæ‰¾åˆ°å‡­æ®']
                        }

                        def username = credentials.username
                        def password = credentials.password.plainText

                        def repoMap = [
                            		'zcf-charge-operation-platform': 'https://codeup.aliyun.com/6552e8ef77eababf21d319a4/business-platform/backend/zcf-charge-operation-platform.git',
		'zcf-busi-middle-office': 'https://codeup.aliyun.com/6552e8ef77eababf21d319a4/middle-office/backend/zcf-busi-middle-office.git',
		'zcf-iot-gateway': 'https://codeup.aliyun.com/6552e8ef77eababf21d319a4/base-framework/backend/zcf-iot-gateway.git',
		'zcf-charge-plat': 'https://codeup.aliyun.com/6552e8ef77eababf21d319a4/business-platform/frontend/zcf-charge-operation-platform-web.git',
		'zcf-charge-tenant': 'https://codeup.aliyun.com/6552e8ef77eababf21d319a4/business-platform/frontend/zcf-charge-operation-tenant-web.git',
		'zcf-data-platform-jobs': 'https://codeup.aliyun.com/6552e8ef77eababf21d319a4/data-middle-office/backend/zcf-data-middle-office-job.git',
		'zcf-data-platform-engine': 'https://codeup.aliyun.com/6552e8ef77eababf21d319a4/data-middle-office/backend/zcf-data-middle-office-job-framework.git',
		'zcf-charge-h5': 'https://codeup.aliyun.com/6552e8ef77eababf21d319a4/business-platform/frontend/zcf-charge-operation-h5.git'
		]

                        def repoUrl = repoMap[REPOSITORY]

                        if (!repoUrl || !BRANCH_OR_TAG) {
                            return ['è¯·å…ˆé€‰æ‹©ä»£ç ä»“åº“å’Œåˆ†æ”¯/æ ‡ç­¾']
                        }

                        def authenticatedUrl = repoUrl.replace('https://', "https://${username}:${password}@")

                        try {
                            def tempDir = File.createTempFile("jenkins-modules-", "")
                            tempDir.delete()
                            tempDir.mkdirs()

                            try {
                                def refName = BRANCH_OR_TAG.replace('origin/', '')
                                def cloneCommand = "git clone --depth 1 --branch ${refName} ${authenticatedUrl} ${tempDir.absolutePath}"

                                def cloneProc = cloneCommand.execute()
                                cloneProc.waitForOrKill(60000)

                                def cloneExitCode = cloneProc.exitValue()

                                if (cloneExitCode != 0) {
                                    return ['å…‹éš†ä»“åº“å¤±è´¥ï¼Œè¯·æ£€æŸ¥åˆ†æ”¯/æ ‡ç­¾åç§°']
                                }

                                def pomFile = new File(tempDir, "pom.xml")

                                if (!pomFile.exists()) {
                                    return ['æœªæ‰¾åˆ° pom.xml æ–‡ä»¶']
                                }

                                def allModules = []
                                def deepScanProjects = [
                                    'zcf-data-platform-jobs': ['job-dwd', 'job-dws', 'job-ods', 'job-ads', 'job-dim'],
                                    'zcf-data-platform-engine': []
                                ]

                                if (deepScanProjects.containsKey(REPOSITORY)) {
                                    def parentModules = deepScanProjects[REPOSITORY]

                                    parentModules.each { parentModule ->
                                        def parentPomFile = new File(tempDir, "${parentModule}/pom.xml")

                                        if (parentPomFile.exists()) {
                                            def parentPomContent = parentPomFile.text
                                            def modulePattern = /<module>([^<]+)<\\/module>/
                                            def matcher = parentPomContent =~ modulePattern

                                            matcher.each { match ->
                                                def subModuleName = match[1].trim()
                                                if (subModuleName && !subModuleName.isEmpty()) {
                                                    allModules.add("[${parentModule}]${subModuleName}".toString())
                                                }
                                            }
                                        }
                                    }
                                }

                                def pomContent = pomFile.text
                                def modulePattern = /<module>([^<]+)<\\/module>/
                                def matcher = pomContent =~ modulePattern

                                matcher.each { match ->
                                    def moduleName = match[1].trim()
                                    if (moduleName && !moduleName.isEmpty()) {
                                        if (!deepScanProjects.containsKey(REPOSITORY) ||
                                            !deepScanProjects[REPOSITORY].contains(moduleName)) {
                                            allModules.add(moduleName.toString())
                                        }
                                    }
                                }

                                if (allModules.isEmpty()) {
                                    return ['æœªæ‰¾åˆ°æ¨¡å—']
                                }

                                return allModules.sort().collect { it.toString() }

                            } finally {
                                tempDir.deleteDir()
                            }

                        } catch (Exception e) {
                            return ["è·å–æ¨¡å—å¤±è´¥: ${e.message}".toString()]
                        }
                    '''
				]
			],
			description: 'é€‰æ‹©è¦æ„å»ºçš„æ¨¡å—ï¼ˆå‰ç«¯é¡¹ç›®æ— éœ€é€‰æ‹©ï¼‰'
		],

		choice(
			name: 'VERSION_MODE',
			choices: ['AUTO_INCREMENT', 'MANUAL', 'DEFAULT'],
			description: '''ç‰ˆæœ¬å·æ¨¡å¼ï¼š
AUTO_INCREMENT - è‡ªåŠ¨ä»å†å²æ„å»ºäº§ç‰©ä¸­è·å–æœ€æ–°ç‰ˆæœ¬å¹¶é€’å¢
MANUAL - æ‰‹åŠ¨æŒ‡å®šæ¯ä¸ªæ¨¡å—ç‰ˆæœ¬
DEFAULT - ä½¿ç”¨é»˜è®¤è§„åˆ™ï¼ˆSNAPSHOTï¼‰'''
		),

		choice(
			name: 'INCREMENT_TYPE',
			choices: ['PATCH', 'MINOR', 'MAJOR'],
			description: '''é€’å¢ç±»å‹ï¼ˆä»… AUTO_INCREMENT æ¨¡å¼ï¼‰ï¼š
PATCH - ä¿®è®¢ç‰ˆæœ¬å· +1 (1.0.2 -> 1.0.3)
MINOR - æ¬¡ç‰ˆæœ¬å· +1 (1.0.2 -> 1.1.0)
MAJOR - ä¸»ç‰ˆæœ¬å· +1 (1.0.2 -> 2.0.0)'''
		),

		string(
			name: 'INITIAL_VERSION',
			defaultValue: '1.0.0',
			description: 'åˆå§‹ç‰ˆæœ¬å·ï¼ˆå½“æ¨¡å—æ²¡æœ‰å†å²ç‰ˆæœ¬æ—¶ä½¿ç”¨ï¼Œä»… AUTO_INCREMENT æ¨¡å¼ï¼‰'
		),

		text(
			name: 'MODULE_VERSIONS',
			defaultValue: '',
			description: '''æ‰‹åŠ¨æŒ‡å®šæ¨¡å—ç‰ˆæœ¬ï¼ˆä»… MANUAL æ¨¡å¼ï¼‰
æ ¼å¼ï¼šæ¨¡å—å=ç‰ˆæœ¬å·ï¼Œæ¯è¡Œä¸€ä¸ª
ç¤ºä¾‹ï¼š
[job-dwd]job-dwd-charging=1.0.0
job-dws-report=1.1.0'''
		),

		string(
			name: 'DEFAULT_VERSION',
			defaultValue: 'SNAPSHOT',
			description: 'é»˜è®¤ç‰ˆæœ¬å·ï¼ˆä»… DEFAULT æ¨¡å¼ï¼‰'
		),

		booleanParam(
			name: 'SKIP_TESTS',
			defaultValue: true,
			description: 'æ˜¯å¦è·³è¿‡å•å…ƒæµ‹è¯•'
		)
	])
])

// ==================== Pipeline ä¸»ä½“ ====================

pipeline {
	agent any

	tools {
		maven 'maven3'
	}

	environment {
		REPO_URL = getRepositoryUrl(params.REPOSITORY)
		CREDENTIALS_ID = '99b27b05-ecce-4a92-a478-f806be8528f3'
		MAVEN_SETTINGS = '/data/apache-maven-3.8.6/conf/settings-zcf-nexus.xml'
		IS_FRONTEND = isFrontendProject(params.REPOSITORY)
		ARTIFACTS_BASE_DIR = '/data/artifacts'
	}

	stages {
		stage('å‡†å¤‡é˜¶æ®µ') {
			steps {
				script {
					echo"""
					æ„å»ºä¿¡æ¯
					==========================================
					ä»£ç ä»“åº“: ${params.REPOSITORY}
					ä»“åº“åœ°å€: ${env.REPO_URL}
					é¡¹ç›®ç±»å‹: ${env.IS_FRONTEND == 'true' ? 'å‰ç«¯é¡¹ç›®' : 'åç«¯é¡¹ç›®'}
					æ„å»ºç±»å‹: ${params.BUILD_TYPE}
					${params.BUILD_TYPE == 'TAG' ? 'æ ‡ç­¾' : 'åˆ†æ”¯'}: ${params.BRANCH_OR_TAG}
					ç‰ˆæœ¬æ¨¡å¼: ${params.VERSION_MODE}
					==========================================
					"""
					if (env.IS_FRONTEND == 'false') {
						echo "æ„å»ºæ¨¡å—: ${params.BUILD_MODULES}"
					}

					if (params.VERSION_MODE == 'AUTO_INCREMENT') {
						echo """
ç‰ˆæœ¬è‡ªå¢é…ç½®:
- é€’å¢ç±»å‹: ${params.INCREMENT_TYPE}
- åˆå§‹ç‰ˆæœ¬: ${params.INITIAL_VERSION}
"""
					} else if (params.VERSION_MODE == 'MANUAL' && params.MODULE_VERSIONS && params.MODULE_VERSIONS.trim()) {
						echo """
æ‰‹åŠ¨ç‰ˆæœ¬é…ç½®:
${params.MODULE_VERSIONS}
"""
					} else {
						echo "é»˜è®¤ç‰ˆæœ¬: ${params.DEFAULT_VERSION}"
					}

					echo """
					è·³è¿‡æµ‹è¯•: ${params.SKIP_TESTS}
					åˆ¶å“å­˜å‚¨: ${env.ARTIFACTS_BASE_DIR}
					==========================================
					"""

					sh """
						mkdir -p ${env.ARTIFACTS_BASE_DIR}/backend
						mkdir -p ${env.ARTIFACTS_BASE_DIR}/frontend
						mkdir -p ${env.ARTIFACTS_BASE_DIR}/releases
					"""
				}
			}
		}

		stage('æ‹‰å–ä»£ç ') {
			steps {
				script {
					cleanWs()

					def refSpec = ''
					def branchSpec = ''

					if (params.BUILD_TYPE == 'TAG') {
						refSpec = '+refs/tags/*:refs/remotes/origin/tags/*'
						branchSpec = "refs/tags/${params.BRANCH_OR_TAG}"
						echo "ğŸ“Œ å‡†å¤‡æ£€å‡ºæ ‡ç­¾: ${params.BRANCH_OR_TAG}"
					} else {
						refSpec = '+refs/heads/*:refs/remotes/origin/*'
						branchSpec = params.BRANCH_OR_TAG
						echo "ğŸŒ¿ å‡†å¤‡æ£€å‡ºåˆ†æ”¯: ${params.BRANCH_OR_TAG}"
					}

					checkout([
						$class: 'GitSCM',
						branches: [[name: branchSpec]],
						userRemoteConfigs: [[
							credentialsId: env.CREDENTIALS_ID,
							url: env.REPO_URL,
							refspec: refSpec
						]],
						extensions: [
							[$class: 'CloneOption', depth: 0, noTags: false, shallow: false]
						]
					])

					echo "âœ… å·²æ£€å‡º ${params.BUILD_TYPE}: ${params.BRANCH_OR_TAG}"
				}
			}
		}

		stage('ç”Ÿæˆç‰ˆæœ¬å·å¹¶æ„å»º') {
			steps {
				script {
					def gitCommitShort = sh(script: "git rev-parse --short HEAD", returnStdout: true).trim()
					def gitCommitTime = sh(script: "git log -1 --format=%cd --date=format:'%Y%m%d%H%M%S'", returnStdout: true).trim()
					def refName = params.BRANCH_OR_TAG.replaceAll('origin/', '').replaceAll('/', '-')

					env.GIT_COMMIT_SHORT = gitCommitShort
					env.GIT_COMMIT_TIME = gitCommitTime
					env.REF_NAME = refName

					// æ ¹æ®ç‰ˆæœ¬æ¨¡å¼è§£æç‰ˆæœ¬å·æ˜ å°„
					def moduleVersionMap = [:]

					echo """
					==========================================
					ç‰ˆæœ¬é…ç½®ä¿¡æ¯
					==========================================
					Git Commit: ${gitCommitShort}
					æäº¤æ—¶é—´: ${gitCommitTime}
					${params.BUILD_TYPE}: ${params.BRANCH_OR_TAG}
					å¼•ç”¨åç§°: ${refName}
					ç‰ˆæœ¬æ¨¡å¼: ${params.VERSION_MODE}
					"""

					if (params.VERSION_MODE == 'AUTO_INCREMENT') {
						echo "é€’å¢ç±»å‹: ${params.INCREMENT_TYPE}"
						echo "åˆå§‹ç‰ˆæœ¬: ${params.INITIAL_VERSION}"
						echo "=========================================="

						// è‡ªåŠ¨é€’å¢æ¨¡å¼ - ä»å†å²æ„å»ºäº§ç‰©ä¸­è·å–ç‰ˆæœ¬
						if (env.IS_FRONTEND == 'true') {
							// å‰ç«¯é¡¹ç›®ç‰ˆæœ¬å·ç”Ÿæˆ
							def newVersion = generateAutoIncrementVersionForFrontend(
								params.REPOSITORY,
								env.ARTIFACTS_BASE_DIR,
								params.INCREMENT_TYPE,
								params.INITIAL_VERSION
							)
							moduleVersionMap[params.REPOSITORY] = newVersion

						} else {
							// åç«¯å¤šæ¨¡å—ç‰ˆæœ¬å·ç”Ÿæˆ
							def modules = params.BUILD_MODULES.split(',')
							modules.each { module ->
								module = module.trim()
								if (module) {
									def newVersion = generateAutoIncrementVersionForBackend(
										params.REPOSITORY,
										module,
										env.ARTIFACTS_BASE_DIR,
										params.INCREMENT_TYPE,
										params.INITIAL_VERSION
									)
									moduleVersionMap[module] = newVersion
								}
							}
						}

					} else if (params.VERSION_MODE == 'MANUAL') {
						echo "ä½¿ç”¨æ‰‹åŠ¨æŒ‡å®šç‰ˆæœ¬"
						echo "=========================================="
						moduleVersionMap = parseModuleVersions(params.MODULE_VERSIONS)

					} else {
						echo "ä½¿ç”¨é»˜è®¤ç‰ˆæœ¬"
						echo "é»˜è®¤ç‰ˆæœ¬: ${params.DEFAULT_VERSION}"
						echo "=========================================="
						// DEFAULT æ¨¡å¼ä¸å¡«å…… moduleVersionMapï¼Œä½¿ç”¨ DEFAULT_VERSION
					}

					if (env.IS_FRONTEND == 'true') {
						// å‰ç«¯é¡¹ç›®æ„å»º
						def buildVersion = getModuleVersion(
							params.REPOSITORY,
							moduleVersionMap,
							gitCommitTime,
							refName,
							params.DEFAULT_VERSION
						)

						env.BUILD_VERSION = buildVersion

						echo "ğŸŒ å‰ç«¯é¡¹ç›®ç‰ˆæœ¬: ${buildVersion}"

						try {
							def packageJsonExists = fileExists('package.json')
							if (!packageJsonExists) {
								error("æœªæ‰¾åˆ° package.json æ–‡ä»¶")
							}

							echo "æ­£åœ¨å®‰è£…ä¾èµ–..."
							sh "/data/nodejs/node-v24.10.0-linux-x64/bin/npm install"

							echo "æ­£åœ¨æ„å»ºé¡¹ç›®..."
							sh "/data/nodejs/node-v24.10.0-linux-x64/bin/npm run build:prod"

							def distDir = "dist"
							if (fileExists(distDir)) {
								def tarName = "${params.REPOSITORY}-${buildVersion}.tar.gz"
								sh "tar -czf ${tarName} ${distDir}"

								env.BUILT_MODULES = params.REPOSITORY
								env.FRONTEND_ARTIFACT = tarName
								echo "âœ… å‰ç«¯é¡¹ç›®æ„å»ºæˆåŠŸï¼Œäº§ç‰©: ${tarName}"
							} else {
								error("æ„å»ºäº§ç‰©ç›®å½• ${distDir} ä¸å­˜åœ¨")
							}

						} catch (Exception e) {
							echo "âŒ å‰ç«¯é¡¹ç›®æ„å»ºå¤±è´¥: ${e.message}"
							throw e
						}

					} else {
						// åç«¯å¤šæ¨¡å—æ„å»º
						echo """
						==========================================
						ğŸ“‹ å¼€å§‹è§£ææ„å»ºæ¨¡å—
						åŸå§‹æ¨¡å—åˆ—è¡¨: ${params.BUILD_MODULES}
						==========================================
						"""

						def modules = params.BUILD_MODULES.split(',')
						def buildResults = [:]
						def builtModulesList = []
						def artifactsList = []
						def moduleVersionsList = []

						echo "è§£æåˆ° ${modules.size()} ä¸ªæ¨¡å—"

						for (module in modules) {
							module = module.trim()

							if (!module) {
								echo "âš ï¸ è·³è¿‡ç©ºæ¨¡å—"
								continue
							}

							def buildPath = '.'
							def moduleName = module
							def parentModule = ''
							def groupId = 'com.zcf.middle-office.data'
							def originalModule = module

							if (module.startsWith('[') && module.contains(']')) {
								def parts = module.split(']', 2)
								parentModule = parts[0].substring(1)
								moduleName = parts[1]
								buildPath = parentModule

								echo """
								ğŸ” æ£€æµ‹åˆ°äºŒçº§å­æ¨¡å—
								åŸå§‹: ${originalModule}
								çˆ¶æ¨¡å—: ${parentModule}
								å­æ¨¡å—: ${moduleName}
								"""
							} else {
								echo "ğŸ” æ™®é€šæ¨¡å—: ${moduleName}"
							}

							// ä¸ºå½“å‰æ¨¡å—è·å–ç‰ˆæœ¬å·ï¼ˆç»Ÿä¸€æ ¼å¼ï¼šcommitTime-refName-versionï¼‰
							def moduleVersion = getModuleVersion(
								originalModule,
								moduleVersionMap,
								gitCommitTime,
								refName,
								params.DEFAULT_VERSION
							)

							echo """
							==========================================
							ğŸ”¨ å¼€å§‹æ„å»ºæ¨¡å—: ${moduleName}
							==========================================
							æ„å»ºè·¯å¾„: ${buildPath}
							æ¨¡å—åç§°: ${moduleName}
							æ¨¡å—ç‰ˆæœ¬: ${moduleVersion}
							"""
							if (parentModule) {
								echo "çˆ¶æ¨¡å—: ${parentModule}"
								echo "GroupId: ${groupId}"
							}
							echo "=========================================="

							try {
								def skipTestsFlag = params.SKIP_TESTS ? '-DskipTests' : ''
								def isDataPlatformJobs = params.REPOSITORY == 'zcf-data-platform-jobs'

								def mavenCommand
								if (parentModule && isDataPlatformJobs) {
									echo "ğŸ“¦ ä½¿ç”¨å®Œæ•´åæ ‡æ„å»ºæ¨¡å¼ï¼ˆzcf-data-platform-jobsï¼‰"
									mavenCommand = """
										cd ${env.WORKSPACE}
										pwd
										echo "æ‰§è¡Œæ„å»ºå‘½ä»¤: mvn clean package -U -pl ${groupId}:${moduleName} -am ${skipTestsFlag}"
										mvn clean package -U -pl ${groupId}:${moduleName} -am ${skipTestsFlag} \
											-s ${MAVEN_SETTINGS} \
											-gs ${MAVEN_SETTINGS}
									"""
								} else if (parentModule) {
									echo "ğŸ“¦ ä½¿ç”¨ç›¸å¯¹è·¯å¾„æ„å»ºæ¨¡å¼"
									mavenCommand = """
										cd ${env.WORKSPACE}/${parentModule}
										pwd
										echo "æ‰§è¡Œæ„å»ºå‘½ä»¤: mvn clean package -U -pl ${moduleName} -am ${skipTestsFlag}"
										mvn clean package -U -pl ${moduleName} -am ${skipTestsFlag} \
											-s ${MAVEN_SETTINGS} \
											-gs ${MAVEN_SETTINGS}
									"""
								} else {
									echo "ğŸ“¦ ä½¿ç”¨æ™®é€šæ„å»ºæ¨¡å¼"
									mavenCommand = """
										cd ${env.WORKSPACE}
										pwd
										echo "æ‰§è¡Œæ„å»ºå‘½ä»¤: mvn clean package -U -pl ${moduleName} -am ${skipTestsFlag}"
										mvn clean package -U -pl ${moduleName} -am ${skipTestsFlag} \
											-s ${MAVEN_SETTINGS} \
											-gs ${MAVEN_SETTINGS}
									"""
								}

								sh mavenCommand

								buildResults[moduleName] = 'SUCCESS'
								echo "âœ… æ¨¡å— ${moduleName} ç¼–è¯‘æˆåŠŸ"

								def jarSearchPath = parentModule ? "${parentModule}/${moduleName}" : moduleName

								echo """
								ğŸ” æŸ¥æ‰¾æ„å»ºäº§ç‰©...
								æœç´¢è·¯å¾„: ${env.WORKSPACE}/${jarSearchPath}/target
								"""

								def targetDirExists = sh(
									script: "[ -d '${env.WORKSPACE}/${jarSearchPath}/target' ] && echo 'yes' || echo 'no'",
									returnStdout: true
								).trim()

								if (targetDirExists == 'no') {
									echo "âŒ target ç›®å½•ä¸å­˜åœ¨: ${env.WORKSPACE}/${jarSearchPath}/target"
									buildResults[moduleName] = 'FAILED'
									continue
								}

								echo "âœ… target ç›®å½•å­˜åœ¨"
								sh "ls -lh ${env.WORKSPACE}/${jarSearchPath}/target/*.jar || true"

								def jarFile = sh(
									script: "find ${env.WORKSPACE}/${jarSearchPath}/target -name '*.jar' -not -name '*-sources.jar' -not -name '*-javadoc.jar' -not -name '*.original' | head -1",
									returnStdout: true
								).trim()

								if (jarFile) {
									echo "âœ… æ‰¾åˆ° jar æ–‡ä»¶: ${jarFile}"

									def jarName = jarFile.split('/').last()
									// ä½¿ç”¨ç»Ÿä¸€æ ¼å¼é‡å‘½åï¼šmoduleName-commitTime-refName-version.jar
									def newJarName = "${moduleName}-${moduleVersion}.jar"
									def newJarPath = "${env.WORKSPACE}/${jarSearchPath}/target/${newJarName}"

									sh "cp ${jarFile} ${newJarPath}"
									echo "âœ… é‡å‘½åäº§ç‰©: ${newJarName}"

									builtModulesList.add(moduleName)
									artifactsList.add("${originalModule}:${newJarPath}:${moduleVersion}")
									moduleVersionsList.add("${moduleName}=${moduleVersion}")
									echo "âœ… æ¨¡å— ${moduleName} æ„å»ºå®Œæˆï¼Œç‰ˆæœ¬: ${moduleVersion}"
								} else {
									echo "âŒ æœªæ‰¾åˆ° jar æ–‡ä»¶"
									buildResults[moduleName] = 'FAILED'
								}

							} catch (Exception e) {
								buildResults[moduleName] = 'FAILED'
								echo """
								âŒ æ¨¡å— ${moduleName} æ„å»ºå¤±è´¥
								é”™è¯¯ä¿¡æ¯: ${e.message}
								"""
							}

							echo ""
						}

						echo """
						==========================================
						ğŸ“Š æ„å»ºç»Ÿè®¡
						==========================================
						æ€»æ¨¡å—æ•°: ${modules.size()}
						æˆåŠŸæ¨¡å—æ•°: ${builtModulesList.size()}
						æˆåŠŸæ¨¡å—: ${builtModulesList.join(', ')}
						==========================================
						æ¨¡å—ç‰ˆæœ¬ä¿¡æ¯:
						${moduleVersionsList.join('\n')}
						==========================================
						"""

						env.BUILD_RESULTS = buildResults.collect { k, v -> "${k}:${v}" }.join(',')
						env.BUILT_MODULES = builtModulesList.size() > 0 ? builtModulesList.join(', ') : 'æ— '
						env.BACKEND_ARTIFACTS = artifactsList.join('|')
						env.MODULE_VERSIONS_BUILT = moduleVersionsList.join('|')

						echo "æœ€ç»ˆæ„å»ºæ¨¡å—: ${env.BUILT_MODULES}"
					}
				}
			}
		}

		stage('å­˜å‚¨æ„å»ºäº§ç‰©') {
			steps {
				script {
					echo """
					==========================================
					å¼€å§‹å­˜å‚¨æ„å»ºäº§ç‰©åˆ°æœ¬åœ°
					==========================================
					"""

					def gitCommitFull = ""
					def gitAuthor = ""
					def gitCommitTime = ""
					def gitCommitMessage = ""

					try {
						gitCommitFull = sh(script: "git rev-parse HEAD", returnStdout: true).trim()
						gitAuthor = sh(script: "git log -1 --format='%an <%ae>'", returnStdout: true).trim()
						gitCommitTime = sh(script: "git log -1 --format='%ci'", returnStdout: true).trim()
						gitCommitMessage = sh(script: "git log -1 --format='%s'", returnStdout: true).trim()
					} catch (Exception e) {
						echo "âš ï¸ è·å– Git ä¿¡æ¯å¤±è´¥: ${e.message}"
						gitCommitFull = "unknown"
						gitAuthor = "unknown"
						gitCommitTime = "unknown"
						gitCommitMessage = "unknown"
					}

					def buildUser = "System"
					try {
						wrap([$class: 'BuildUser']) {
							buildUser = env.BUILD_USER ?: 'System'
						}
					} catch (Exception e) {
						buildUser = 'System'
					}

					def jenkinsNode = env.NODE_NAME ?: 'master'

					if (env.IS_FRONTEND == 'true') {
						def tarFile = env.FRONTEND_ARTIFACT
						def targetDir = "${env.ARTIFACTS_BASE_DIR}/frontend/${params.REPOSITORY}"

						sh "mkdir -p ${targetDir}"
						sh "cp ${tarFile} ${targetDir}/"

						def targetPath = "${targetDir}/${tarFile}"
						def fileSize = sh(script: "du -h ${targetPath} | cut -f1", returnStdout: true).trim()
						def fileMd5 = sh(script: "md5sum ${targetPath} | cut -d' ' -f1", returnStdout: true).trim()

						echo """
						âœ… å‰ç«¯äº§ç‰©å·²å­˜å‚¨
						è·¯å¾„: ${targetPath}
						å¤§å°: ${fileSize}
						MD5: ${fileMd5}
                        """

						def metadata = [
							project: params.REPOSITORY,
							type: 'frontend',
							buildType: params.BUILD_TYPE,
							refName: params.BRANCH_OR_TAG,
							versionMode: params.VERSION_MODE,
							version: env.BUILD_VERSION,
							artifact: tarFile,
							path: targetPath,
							size: fileSize,
							md5: fileMd5,
							gitCommit: env.GIT_COMMIT_SHORT ?: 'unknown',
							gitCommitFull: gitCommitFull,
							gitBranch: params.BRANCH_OR_TAG,
							gitAuthor: gitAuthor,
							gitCommitTime: gitCommitTime,
							gitCommitMessage: gitCommitMessage,
							buildTime: new Date().format('yyyy-MM-dd HH:mm:ss'),
							buildNumber: env.BUILD_NUMBER,
							buildUrl: env.BUILD_URL ?: 'unknown',
							buildUser: buildUser,
							jenkinsNode: jenkinsNode
						]

						def jsonString = JsonOutput.toJson(metadata)
						def prettyJson = JsonOutput.prettyPrint(jsonString)
						prettyJson = decodeUnicode(prettyJson)

						writeFile file: "${targetDir}/${tarFile}.json", text: prettyJson, encoding: 'UTF-8'
						echo "   å…ƒæ•°æ®: ${targetDir}/${tarFile}.json"

					} else {
						def artifacts = env.BACKEND_ARTIFACTS.split('\\|')
						def storedCount = 0

						for (artifact in artifacts) {
							def parts = artifact.split(':')
							if (parts.size() != 3) continue

							def originalModuleName = parts[0].trim()
							def jarPath = parts[1].trim()
							def moduleVersion = parts[2].trim()

							def moduleName = originalModuleName
							if (originalModuleName.contains(']')) {
								moduleName = originalModuleName.split(']')[1]
							}

							if (!fileExists(jarPath)) {
								echo "âš ï¸ æ–‡ä»¶ä¸å­˜åœ¨ï¼Œè·³è¿‡: ${jarPath}"
								continue
							}

							def jarName = jarPath.split('/').last()
							def targetDir = "${env.ARTIFACTS_BASE_DIR}/backend/${params.REPOSITORY}/${moduleName}"

							sh "mkdir -p ${targetDir}"
							sh "cp ${jarPath} ${targetDir}/"

							def targetPath = "${targetDir}/${jarName}"
							def fileSize = sh(script: "du -h ${targetPath} | cut -f1", returnStdout: true).trim()
							def fileMd5 = sh(script: "md5sum ${targetPath} | cut -d' ' -f1", returnStdout: true).trim()

							echo """
							âœ… ${moduleName} å·²å­˜å‚¨
							è·¯å¾„: ${targetPath}
							ç‰ˆæœ¬: ${moduleVersion}
							å¤§å°: ${fileSize}
							MD5: ${fileMd5}
							"""

							def moduleMetadata = [
								project: params.REPOSITORY,
								module: moduleName,
								originalModule: originalModuleName,
								type: 'backend',
								buildType: params.BUILD_TYPE,
								refName: params.BRANCH_OR_TAG,
								versionMode: params.VERSION_MODE,
								version: moduleVersion,
								artifact: jarName,
								path: targetPath,
								size: fileSize,
								md5: fileMd5,
								gitCommit: env.GIT_COMMIT_SHORT ?: 'unknown',
								gitCommitFull: gitCommitFull,
								gitBranch: params.BRANCH_OR_TAG,
								gitAuthor: gitAuthor,
								gitCommitTime: gitCommitTime,
								gitCommitMessage: gitCommitMessage,
								buildTime: new Date().format('yyyy-MM-dd HH:mm:ss'),
								buildNumber: env.BUILD_NUMBER,
								buildUrl: env.BUILD_URL ?: 'unknown',
								buildUser: buildUser,
								jenkinsNode: jenkinsNode
							]

							def jsonString = JsonOutput.toJson(moduleMetadata)
							def prettyJson = JsonOutput.prettyPrint(jsonString)
							prettyJson = decodeUnicode(prettyJson)

							writeFile file: "${targetDir}/${jarName}.json", text: prettyJson, encoding: 'UTF-8'

							storedCount++
						}

						echo """
						==========================================
						å­˜å‚¨ç»Ÿè®¡: æˆåŠŸ ${storedCount} ä¸ªæ¨¡å—
						==========================================
						"""
					}
				}
			}
		}

		stage('å½’æ¡£åˆ° Jenkins') {
			steps {
				script {
					echo "æ­£åœ¨å½’æ¡£æ„å»ºäº§ç‰©åˆ° Jenkins..."

					try {
						if (env.IS_FRONTEND == 'true') {
							archiveArtifacts artifacts: "*.tar.gz", fingerprint: true
							echo "âœ… å‰ç«¯äº§ç‰©å·²å½’æ¡£åˆ° Jenkins"
						} else {
							def modules = params.BUILD_MODULES.split(',')
							def archived = false

							modules.each { module ->
								module = module.trim()

								def moduleName = module
								def parentModule = ''

								if (module.startsWith('[') && module.contains(']')) {
									def parts = module.split(']', 2)
									parentModule = parts[0].substring(1)
									moduleName = parts[1]
								}

								def jarSearchPath = parentModule ? "${parentModule}/${moduleName}" : moduleName
								def pattern = "${jarSearchPath}/target/${moduleName}-*.jar"

								if (findFiles(glob: pattern).size() > 0) {
									archiveArtifacts artifacts: pattern, fingerprint: true, allowEmptyArchive: true
									archived = true
								}
							}

							if (archived) {
								echo "âœ… åç«¯äº§ç‰©å·²å½’æ¡£åˆ° Jenkins"
							}
						}
					} catch (Exception e) {
						echo "âš ï¸ å½’æ¡£å¤±è´¥: ${e.message}"
					}
				}
			}
		}

		stage('æ¸…ç†æ—§ç‰ˆæœ¬') {
			steps {
				script {
					echo "æ­£åœ¨æ¸…ç†æ—§ç‰ˆæœ¬..."

					try {
						def projectType = env.IS_FRONTEND == 'true' ? 'frontend' : 'backend'
						def projectDir = "${env.ARTIFACTS_BASE_DIR}/${projectType}/${params.REPOSITORY}"

						if (params.VERSION_MODE == 'DEFAULT') {
							sh """
								cd ${projectDir}
								find . -name "*-SNAPSHOT.jar" -o -name "*-SNAPSHOT.tar.gz" | \
								sort -r | tail -n +31 | xargs -r rm -f
								find . -name "*-SNAPSHOT.jar.json" -o -name "*-SNAPSHOT.tar.gz.json" | \
								sort -r | tail -n +31 | xargs -r rm -f
							"""
							echo "âœ… å·²æ¸…ç†æ—§çš„ SNAPSHOT ç‰ˆæœ¬ï¼ˆä¿ç•™æœ€è¿‘ 30 ä¸ªï¼‰"
						}

					} catch (Exception e) {
						echo "âš ï¸ æ¸…ç†å¤±è´¥: ${e.message}"
					}
				}
			}
		}
	}

	post {
		always {
			script {
				def buildUser = 'System'
				try {
					wrap([$class: 'BuildUser']) {
						buildUser = env.BUILD_USER ?: 'System'
					}
				} catch (Exception e) {
					buildUser = 'System'
				}

				def version = env.BUILD_VERSION ?: env.MODULE_VERSIONS_BUILT?.split('\\|')?.first()?.split('=')?.last() ?: 'æœªæŒ‡å®š'
				def modules = env.BUILT_MODULES ?: 'æ— '
				def projectType = env.IS_FRONTEND == 'true' ? 'ğŸŒ' : 'â˜•'
				def buildTypeIcon = params.BUILD_TYPE == 'TAG' ? 'ğŸ·ï¸' : 'ğŸŒ¿'
				def versionModeIcon = params.VERSION_MODE == 'AUTO_INCREMENT' ? 'ğŸ”„' : (params.VERSION_MODE == 'MANUAL' ? 'âœï¸' : 'â°')
				def buildStatus = currentBuild.result ?: 'SUCCESS'
				def statusIcon = buildStatus == 'SUCCESS' ? 'âœ…' : 'âŒ'

				currentBuild.description = """
				${buildTypeIcon} ${params.BRANCH_OR_TAG} |
				${versionModeIcon} ${params.VERSION_MODE} |
				${projectType} ${modules} |
                ğŸ“¦ ${version} |
                ğŸ‘¤ ${buildUser} |
                ${statusIcon}
            """.replaceAll(/\s+/, ' ').trim()
			}
		}

		success {
			script {
				def projectType = env.IS_FRONTEND == 'true' ? 'frontend' : 'backend'
				def storagePath = "${env.ARTIFACTS_BASE_DIR}/${projectType}/${params.REPOSITORY}"

				echo """
				==========================================
				ğŸ‰ æ„å»ºå®Œæˆ
				==========================================
				æ„å»ºç±»å‹: ${params.BUILD_TYPE}
				${params.BUILD_TYPE == 'TAG' ? 'æ ‡ç­¾' : 'åˆ†æ”¯'}: ${params.BRANCH_OR_TAG}
				ç‰ˆæœ¬æ¨¡å¼: ${params.VERSION_MODE}
				æ„å»ºæ¨¡å—: ${env.BUILT_MODULES}
				"""

				if (env.MODULE_VERSIONS_BUILT) {
					echo "æ¨¡å—ç‰ˆæœ¬:"
					env.MODULE_VERSIONS_BUILT.split('\\|').each { mv ->
						echo "  ${mv}"
					}
				}

				echo """
				å­˜å‚¨è·¯å¾„: ${storagePath}
				Jenkins å½’æ¡£: ${env.BUILD_URL}artifact/
				==========================================
				"""
			}
		}

		failure {
			echo "âŒ æ„å»ºå¤±è´¥ï¼è¯·æŸ¥çœ‹æ—¥å¿—æ’æŸ¥é—®é¢˜ã€‚"
		}
	}
}

// ==================== ç‰ˆæœ¬å·è‡ªå¢å‡½æ•°ï¼ˆåœ¨ pipeline å—ä¹‹åå®šä¹‰ï¼‰====================

def generateAutoIncrementVersionForFrontend(String repository, String artifactsBaseDir, String incrementType, String initialVersion) {
	echo "ğŸ”„ ä¸ºå‰ç«¯é¡¹ç›®ç”Ÿæˆç‰ˆæœ¬å·..."

	def projectDir = "${artifactsBaseDir}/frontend/${repository}"
	def allVersions = []

	try {
		def dirExists = sh(script: "[ -d '${projectDir}' ] && echo 'yes' || echo 'no'", returnStdout: true).trim()
		if (dirExists == 'yes') {
			def jsonFiles = sh(script: "find '${projectDir}' -name '*.json' -type f 2>/dev/null || true", returnStdout: true).trim()
			if (jsonFiles) {
				jsonFiles.split('\n').each { jsonFile ->
					if (jsonFile && jsonFile.trim()) {
						try {
							def jsonContent = sh(script: "cat '${jsonFile}' 2>/dev/null || true", returnStdout: true).trim()
							if (jsonContent) {
								def json = readJSON text: jsonContent
								if (json.version) {
									// ä»å®Œæ•´ç‰ˆæœ¬å·ä¸­æå–çº¯ç‰ˆæœ¬å·éƒ¨åˆ†ï¼ˆå»æ‰ commitTime å’Œ refNameï¼‰
									def versionStr = json.version.toString()
									// æ ¼å¼ï¼š20260106200636-master-1.0.3
									// æå–æœ€åä¸€æ®µï¼ˆ1.0.3ï¼‰
									def parts = versionStr.split('-')
									if (parts.size() >= 3) {
										allVersions.add(parts[-1])
									}
								}
							}
						} catch (Exception e) {
							// å¿½ç•¥
						}
					}
				}
			}
		}
	} catch (Exception e) {
		echo "âš ï¸ è·å–å†å²ç‰ˆæœ¬å¤±è´¥: ${e.message}"
	}

	if (allVersions.isEmpty()) {
		echo "ğŸ“¦ ä½¿ç”¨åˆå§‹ç‰ˆæœ¬: ${initialVersion}"
		return initialVersion
	}

	allVersions = allVersions.unique()
	echo "ğŸ“‹ æ‰¾åˆ° ${allVersions.size()} ä¸ªå†å²ç‰ˆæœ¬"

	def latestParsed = findLatestVersion(allVersions)
	if (!latestParsed) {
		echo "âš ï¸ æ— æ³•è§£æå†å²ç‰ˆæœ¬ï¼Œä½¿ç”¨åˆå§‹ç‰ˆæœ¬"
		return initialVersion
	}

	def latestVersionStr = "${latestParsed.major}.${latestParsed.minor}.${latestParsed.patch}"
	def newVersion = incrementVersion(latestParsed, incrementType)
	echo "âœ… ${latestVersionStr} -> ${newVersion}"

	return newVersion
}

def generateAutoIncrementVersionForBackend(String repository, String moduleName, String artifactsBaseDir, String incrementType, String initialVersion) {
	echo "ğŸ”„ ä¸ºæ¨¡å— ${moduleName} ç”Ÿæˆç‰ˆæœ¬å·..."

	def actualModuleName = moduleName.contains(']') ? moduleName.split(']')[1] : moduleName
	def moduleDir = "${artifactsBaseDir}/backend/${repository}/${actualModuleName}"
	def allVersions = []

	try {
		def dirExists = sh(script: "[ -d '${moduleDir}' ] && echo 'yes' || echo 'no'", returnStdout: true).trim()
		if (dirExists == 'yes') {
			def jsonFiles = sh(script: "find '${moduleDir}' -name '*.json' -type f 2>/dev/null || true", returnStdout: true).trim()
			if (jsonFiles) {
				jsonFiles.split('\n').each { jsonFile ->
					if (jsonFile && jsonFile.trim()) {
						try {
							def jsonContent = sh(script: "cat '${jsonFile}' 2>/dev/null || true", returnStdout: true).trim()
							if (jsonContent) {
								def json = readJSON text: jsonContent
								if (json.version) {
									// ä»å®Œæ•´ç‰ˆæœ¬å·ä¸­æå–çº¯ç‰ˆæœ¬å·éƒ¨åˆ†ï¼ˆå»æ‰ commitTime å’Œ refNameï¼‰
									def versionStr = json.version.toString()
									// æ ¼å¼ï¼š20260106200636-master-1.0.3
									// æå–æœ€åä¸€æ®µï¼ˆ1.0.3ï¼‰
									def parts = versionStr.split('-')
									if (parts.size() >= 3) {
										allVersions.add(parts[-1])
									}
								}
							}
						} catch (Exception e) {
							// å¿½ç•¥
						}
					}
				}
			}
		}
	} catch (Exception e) {
		echo "âš ï¸ è·å–å†å²ç‰ˆæœ¬å¤±è´¥: ${e.message}"
	}

	if (allVersions.isEmpty()) {
		echo "ğŸ“¦ ä½¿ç”¨åˆå§‹ç‰ˆæœ¬: ${initialVersion}"
		return initialVersion
	}

	allVersions = allVersions.unique()
	echo "ğŸ“‹ æ‰¾åˆ° ${allVersions.size()} ä¸ªå†å²ç‰ˆæœ¬"

	def latestParsed = findLatestVersion(allVersions)
	if (!latestParsed) {
		echo "âš ï¸ æ— æ³•è§£æå†å²ç‰ˆæœ¬ï¼Œä½¿ç”¨åˆå§‹ç‰ˆæœ¬"
		return initialVersion
	}

	def latestVersionStr = "${latestParsed.major}.${latestParsed.minor}.${latestParsed.patch}"
	def newVersion = incrementVersion(latestParsed, incrementType)
	echo "âœ… ${latestVersionStr} -> ${newVersion}"

	return newVersion
}
